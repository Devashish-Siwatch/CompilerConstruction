DECLARE	6	declare
MODULE	6	module
ID	6	readArr
SEMICOL	6	;
DEF	7	<<
MODULE	7	module
ID	7	arraySum
ENDDEF	7	>>
TAKES	8	takes
INPUT	8	input
SQBO	8	[
ID	8	list
COLON	8	:
ARRAY	8	array
SQBO	8	[
NUM	8	1
RANGEOP	8	..
NUM	8	15
SQBC	8	]
OF	8	of
REAL	8	real
COMMA	8	,
ID	8	n
COLON	8	:
INTEGER	8	integer
SQBC	8	]
SEMICOL	8	;
RETURNS	9	returns
SQBO	9	[
ID	9	sum
COLON	9	:
REAL	9	real
SQBC	9	]
SEMICOL	9	;
START	10	start
DECLARE	11	declare
ID	11	index
COLON	11	:
INTEGER	11	integer
SEMICOL	11	;
DECLARE	12	declare
ID	12	t
COLON	12	:
BOOLEAN	12	boolean
SEMICOL	12	;
ID	13	sum
ASSIGNOP	13	:=
RNUM	13	0.0
SEMICOL	13	;
FOR	14	for
BO	14	(
ID	14	index
IN	14	in
MINUS	14	-
NUM	14	10
RANGEOP	14	..
PLUS	14	+
NUM	14	15
BC	14	)
START	15	start
ID	16	t
ASSIGNOP	16	:=
ID	16	index
LE	16	<=
ID	16	n
SEMICOL	16	;
SWITCH	17	switch
BO	17	(
ID	17	t
BC	17	)
START	18	start
CASE	19	case
TRUE	19	true
COLON	19	:
PRINT	19	print
BO	19	(
ID	19	list
SQBO	19	[
PLUS	19	+
ID	19	index
SQBC	19	]
BC	19	)
SEMICOL	19	;
ID	20	sum
ASSIGNOP	20	:=
ID	20	sum
PLUS	20	+
ID	20	list
SQBO	20	[
ID	20	index
SQBC	20	]
SEMICOL	20	;
BREAK	21	break
SEMICOL	21	;
CASE	22	case
FALSE	22	false
COLON	22	:
PRINT	22	print
BO	22	(
ID	22	sum
BC	22	)
SEMICOL	22	;
PRINT	23	print
BO	23	(
ID	23	index
BC	23	)
SEMICOL	23	;
BREAK	24	break
SEMICOL	24	;
END	25	end
END	26	end
PRINT	27	print
BO	27	(
ID	27	sum
BC	27	)
SEMICOL	27	;
END	28	end
DRIVERDEF	30	<<<
DRIVER	30	driver
PROGRAM	30	program
DRIVERENDDEF	30	>>>
START	31	start
DECLARE	32	declare
ID	32	A
COLON	32	:
ARRAY	32	array
SQBO	32	[
NUM	32	1
RANGEOP	32	..
NUM	32	15
SQBC	32	]
OF	32	of
REAL	32	real
SEMICOL	32	;
DECLARE	33	declare
ID	33	k
COLON	33	:
INTEGER	33	integer
SEMICOL	33	;
DECLARE	34	declare
ID	34	s
COLON	34	:
REAL	34	real
SEMICOL	34	;
GET_VALUE	35	get_value
BO	35	(
ID	35	k
BC	35	)
SEMICOL	35	;
USE	36	use
MODULE	36	module
ID	36	readArr
WITH	36	with
PARAMETERS	36	parameters
ID	36	A
COMMA	36	,
ID	36	k
SEMICOL	36	;
SQBO	37	[
ID	37	s
SQBC	37	]
ASSIGNOP	37	:=
USE	37	use
MODULE	37	module
ID	37	arraySum
WITH	37	with
PARAMETERS	37	parameters
ID	37	A
COMMA	37	,
ID	37	k
SEMICOL	37	;
PRINT	38	print
BO	38	(
ID	38	s
BC	38	)
SEMICOL	38	;
END	39	end
DEF	42	<<
MODULE	42	module
ID	42	readArr
ENDDEF	42	>>
TAKES	43	takes
INPUT	43	input
SQBO	43	[
ID	43	arr1
COLON	43	:
ARRAY	43	array
SQBO	43	[
MINUS	43	-
NUM	43	10
RANGEOP	43	..
NUM	43	25
SQBC	43	]
OF	43	of
REAL	43	real
COMMA	43	,
ID	43	k
COLON	43	:
INTEGER	43	integer
SQBC	43	]
SEMICOL	43	;
START	44	start
DECLARE	45	declare
ID	45	tempvar
COLON	45	:
REAL	45	real
SEMICOL	45	;
DECLARE	46	declare
ID	46	i
COLON	46	:
INTEGER	46	integer
SEMICOL	46	;
ID	48	i
ASSIGNOP	48	:=
NUM	48	1
SEMICOL	48	;
WHILE	49	while
BO	49	(
ID	49	i
LE	49	<=
ID	49	k
BC	49	)
START	50	start
GET_VALUE	51	get_value
BO	51	(
ID	51	tempvar
BC	51	)
SEMICOL	51	;
ID	52	arr1
SQBO	52	[
ID	52	i
SQBC	52	]
ASSIGNOP	52	:=
ID	52	tempvar
SEMICOL	52	;
DECLARE	53	declare
ID	53	B
COLON	53	:
ARRAY	53	array
SQBO	53	[
MINUS	53	-
ID	53	p
RANGEOP	53	..
PLUS	53	+
ID	53	q
SQBC	53	]
OF	53	of
BOOLEAN	53	boolean
SEMICOL	53	;
ID	54	tempvar
ASSIGNOP	54	:=
MINUS	54	-
BO	54	(
ID	54	tempvar
PLUS	54	+
ID	54	B
SQBO	54	[
ID	54	a
PLUS	54	+
ID	54	b
MUL	54	*
ID	54	c
SQBC	54	]
PLUS	54	+
ID	54	A
SQBO	54	[
PLUS	54	+
NUM	54	5
SQBC	54	]
MINUS	54	-
ID	54	A
SQBO	54	[
MINUS	54	-
NUM	54	10
SQBC	54	]
BC	54	)
SEMICOL	54	;
ID	55	B
SQBO	55	[
ID	55	k
SQBC	55	]
ASSIGNOP	55	:=
MINUS	55	-
NUM	55	10
SEMICOL	55	;
ID	56	i
ASSIGNOP	56	:=
ID	56	i
PLUS	56	+
NUM	56	1
SEMICOL	56	;
END	57	end
END	58	end
